

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>[翻译]Next Consensus Architecture Proposal</title>
    <meta name="description" content="">
    <meta name="author" content="梧桐树">

    <!-- Enable responsive viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/themes/twitter/bootstrap/css/bootstrap.2.2.2.min.css" rel="stylesheet">
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">

    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->

    <!-- atom & rss feed -->
    <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
    <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">

  </head>

  <body>
    <div class="navbar">
      <div class="navbar-inner">
        <div class="container-narrow">
          <a class="brand" href="/">区块链实用手册</a>
          <ul class="nav">
            
            
            


  
    
      
      	
      	<li><a href="/hyperledger">Hyperledger源码分析</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/devops">动手实战</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/translations">原创翻译</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/news">相关技术</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/resources">网络资源</a></li>
      	
      
    
  




          </ul>
        </div>
      </div>
    </div>

    <div class="container-narrow">

      <div class="content">
        

<div class="page-header">
  <h1>[翻译]Next Consensus Architecture Proposal </h1>
</div>

<div class="row-fluid">
  <div class="span12">
    
<p>原文：<a href="https://github.com/hyperledger/fabric/blob/master/proposals/r1/Next-Consensus-Architecture-Proposal.md">https://github.com/hyperledger/fabric/blob/master/proposals/r1/Next-Consensus-Architecture-Proposal.md</a></p>

<p>作者: Elli Androulaki, Christian Cachin, Angelo De Caro, Konstantinos Christidis, Chet Murthy, Binh Nguyen, Alessandro Sorniotti, and Marko Vukolić</p>

<p>翻译：<a href="https://wutongtree.com">梧桐树</a></p>

<hr />

<p>这篇文档记录的是区块链基础架构，区块链节点根据角色分为<em>peers</em>（维护状态/总账的节点）和<em>consenters</em>（批准区块链状态中交易顺序的节点）。在通常的区块链架构中（包括2016年7月的Hyperledger fabric），这些角色都是集成的（参看Hyperledger fabic的<em>validating peer</em>）。这个架构还引入了背书节点（endorsers）的概念，它其实是一种特殊类型的节点，用来模拟执行和背书交易（大概和Hyperldger fabric 0.5-developer-preview的执行/验证交易是类似的）。</p>

<p>这种架构和peers/consenters/endorsers集成的设计相比有如下的优势：</p>

<ul>
  <li><strong>链码的可信灵活性（chaincode trust flexibility）</strong>。从架构上，区分开链码（区块链应用程序）是<em>可信</em>的<em>假设</em>和共识是不可信的假设。就是说，参与到共识服务中的节点可能是批准节点（consenters），也能容忍一些节点失败或者捣乱。每个链码的背书节点也可能是不一样的。</li>
  <li><strong>可扩展性（Scalability）</strong>。负责特定链码的背书节点和批准节点是正交的，这比所有功能都在同一个节点完成更好扩展。尤其是，当最终不同的链码都指定不同的背书节点时，链码会在不同的背书节点上分散开，它们就可以并行执行了，链码执行这里叫背书（endorsement）。另外，链码执行是非常耗时的，已经从共识服务的关键路径中移除了。</li>
  <li><strong>机密性（Confidentiality）</strong>。这个架构使对内容和执行状态更新有<em>机密性</em>要求的链码部署更容易了。</li>
  <li><strong>共识模块性（Consensus modularity）</strong>。这个架构是<em>模块化的</em>，运行插件化的共识实现。</li>
</ul>

<h2 id="section">目录</h2>
<ol>
  <li>系统架构</li>
  <li>基本的交易背书工作流</li>
  <li>背书策略</li>
  <li>区块链数据结构</li>
  <li>状态转换和检查点</li>
  <li>机密性</li>
</ol>

<hr />

<h2 id="section-1">1. 系统架构</h2>
<p>区块链是由很多相互通信的节点组成的分布式系统。区块链运行程序（叫链码），保存状态和总账数据，执行交易。链码是最核心的元素，交易是在链码上执行的操作，并且只有链码才能更改状态。交易必须要有背书，只有有背书的交易才能被提交，才能影响状态。有一些具有管理功能和参数的特殊链码，统称<em>系统链码</em>。</p>

<h3 id="section-2">1.1. 交易</h3>

<p>交易有两种类型：</p>

<ul>
  <li><em>部署交易（Deploy transactions）</em> 用程序作为它的一个参数创建新的链码。当部署交易成功执行以后，我们就说链码被安装到“链上”了。</li>
  <li><em>调用交易（Invoke transactions）</em> 在前面部署的链码上执行一个操作。一个调用交易指的是链码和它提供的功能。如果成功的话，链码会执行指定的功能，可能会修改相关的状态，然后返回输出。</li>
</ul>

<p>后面还会介绍，部署交易是调用交易的特殊情况，调用交易创建新的链码就是在系统链码上的调用交易。</p>

<p><strong>注意</strong>：<em>这个文档假设一个交易创建新的链码或者调用交易都是在已经部署的链码上操作的。这个文档没有描述如下内容：a) 支持跨链码的交易; b) 查询交易（只读的）的优化</em>。</p>

<h3 id="state">1.2. 状态（State）</h3>

<p><strong>区块链状态（Blockchain state）</strong>。区块链的状态（世界状态：world state）有一个简单的结构，建模成了一个带版本控制的KV存储（KVS），其中键是名称，值是任意的二进制大对象。这些数据由运行在区块链上的链码通过<code>put</code>和<code>get</code>的KVS进行操作。这些状态是被永久存储的，更新状态也会写日志。注意带版本控制的KVS只是状态的模型，实现方式可以实际的KVS系统，也可以是关系型数据库系统或者其他的解决方案。</p>

<p>形式化的表示就是，区块链状态<code>s</code>是<code>K -&gt; (V X N)</code>映射的一个元素，其中：</p>

<ul>
  <li><code>K</code>是键的集合</li>
  <li><code>V</code>是值的集合</li>
  <li><code>N</code>是无数个有序的版本号集合。单射函数<code>next: N -&gt; N</code>有输入<code>N</code>的一个元素，返回下一个版本号。</li>
</ul>

<p><code>V</code>和<code>N</code>都有一个特殊的元素<code>\bot</code>，代表<code>N</code>最小的元素。初始化的时候，所有的键都被映射到<code>(\bot,\bot)</code>。<code>s(k)=(v,ver)</code>这个表达式中，<code>v</code>用<code>s(k).value</code>来表示，<code>ver</code>用<code>s(k).version</code>来表示。</p>

<p>KVS操作是这样建模的：</p>

<ul>
  <li><code>put(k,v)</code>操作。对<code>k\in K</code>和<code>v\in V</code>键值对，区块链状态<code>s</code>的新状态<code>s'</code>计算方法是：<code>s'(k)=(v,next(s(k).version))</code>。并且对所有的<code>k'!=k</code>，表达式<code>s'(k')=s(k')</code>都成立。</li>
  <li><code>get(k) </code>操作。返回<code>s(k)</code>。</li>
</ul>

<p><strong>状态分区（State partitioning）</strong>。KVS中的键可以通过名称就能识别出它们属于哪个链码，所以只有特定链码的交易才能修改属于这个链码的键。原则上，任意的链码都能读取属于其他链码的键（当然机密链码的状态是不能读的，参考第6部分）。<em>修改2个或者多个链码状态的跨链交易，以后会支持。</em></p>

<p><strong>总账（Ledger）</strong>。区块链状态的变化过程（历史）是保存在<em>总账</em>中的。总账是交易区块的散列链（hashchain），总账中的交易是全序的。</p>

<p>区块链状态和总账会在第4部分详细描述。</p>

<h3 id="nodes">1.3. 节点（Nodes）</h3>

<p>节点是区块链的通信实体。节点是一个逻辑的概念，不同类型的节点是可以运行在同一个物理服务器上的。重要的是节点是怎么被分组成“信任域（trust domains）”，怎么和控制它们的逻辑实体关联的。</p>

<p>有3种类型的节点：</p>

<ol>
  <li>
    <p><strong>客户端（Client）</strong>或者<strong>提交客户端（submitting-client）</strong>：提交实际交易请求的客户端。</p>
  </li>
  <li>
    <p><strong>伙伴（Peer）</strong>：一个提交交易，维护状态和总账副本的节点。伙伴有两种特殊的角色：</p>

    <p>a. <strong>提交伙伴（submitting peer）</strong>或者<strong>提交者（submitter）</strong></p>

    <p>b. <strong>背书伙伴（endorsing peer）</strong>或者<strong>背书者（endorser）</strong></p>
  </li>
  <li>
    <p><strong>共识服务节点（Consensus-service-node）</strong>或者<strong>批准者（consenter）</strong>：一个运行了有送达保证（delivery guarantee，比如原子广播）通信服务的节点，送达保证典型的实现方法是运行共识服务。</p>
  </li>
</ol>

<p>注意，批准者和客户端是不维护总账和区块链状态的，只有伙伴才会。</p>

<p>节点的类型下面会详细解释。</p>

<h4 id="client">1.3.1. 客户端（Client）</h4>

<p>客户端表示的是代表终端用户的实体，它必须连接到伙伴才能和区块链通信。客户端可以根据自己的选择连接到任意一个伙伴上，然后创建再调用交易。</p>

<h4 id="peer">1.3.2. 伙伴（Peer）</h4>

<p>伙伴通过共识服务通信维护区块链状态和总账。它们从共识服务接收有序的更新状态，然后更新本地维护的状态。</p>

<p>伙伴可以选择下面描述的两种角色：</p>

<ul>
  <li>
    <p><strong>提交伙伴（Submitting peer）</strong>。<em>提交伙伴</em>是一种特殊的角色，它给客户端提供接口，这样客户端就可以连接到提交伙伴调用交易和获取结果。这个伙伴代表一个或者多个客户端和其他节点通信来执行交易。</p>
  </li>
  <li>
    <p><strong>背书伙伴（Endorsing peer）</strong>。<em>背书伙伴</em>的特殊功能是对特定的链码，在其提交交易前对它进行<em>背书</em>。每个链码都可以指定一个<em>背书策略</em>，可能会涉及背书伙伴的集合。策略会定义一个有效的交易背书（典型情况是背书着的签名集合）的充要条件，这会在第2和3部分描述。一个特殊情况是，安装新链码的部署交易中，（部署）背书策略是系统链码的背书策略指定的。</p>
  </li>
</ul>

<p>强调一个伙伴同时有提交伙伴和背书伙伴角色的时候，就叫它<em>交付伙伴（committing peer）</em>。</p>

<h4 id="consensus-service-node-consenters">1.3.3. 共识服务节点（Consensus service node (Consenters)）</h4>

<p><em>批准者</em>组成了<em>共识服务</em>，比如，一个提供交付保证的通信组织。共识服务可以有多种实现方式：从中心化的服务（比如：部署和测试）到目标是不同网络和节点容错模型的分布式协议。</p>

<p>伙伴是共识服务的客户端，在于共识服务给它提供了一个有广播交易信息的共享<em>通信通道</em>。伙伴连接到通道上，可以发送或者接收消息。通道支持所有消息的<em>原子</em>交付，就是，消息通信是全序交付的和（跟实现相关）可靠的。换句话说，通道输出给所有连接的节点相同的消息，而且输出的逻辑顺序是相同的。原子通信保证又叫<em>全序广播（total-order broadcast）</em>，<em>原子广播（atomic broadcast）</em>，或者分布式系统环境下的<em>共识（consensus）</em>。通信过的消息就是会保存在区块链状态中的候选交易了。</p>

<p><strong>共识通道分区（Partitioning (consensus channels)）</strong>。共识服务可能支持多<em>通道</em>，类似发布/订阅（pub/sub）消息系统的<em>主题</em>。客户端链接到一个指定的通道，就可以发送或者获取到达的消息。通道可能会有分区 - 客户端连接到一个通道是不知道其他通道的存在的，但是客户端可以连接到多个通道。为简单起见，本文档后面的部分，除非明确的提到了的其他情况，我们都假设共识服务是有单个通道/主题组成的。</p>

<p><strong>共识服务API（Consensus service API）</strong>。伙伴连接到共识服务提供的通道，是通过共识服务的API。共识服务API有两种基本的操作（更通用的叫<em>异步事件</em>）：</p>

<ul>
  <li>
    <p><code>broadcast(blob)</code>：提交伙伴调用它在通道上广播任意的消息<code>blob</code>。这在BFT中，给服务发送一个请求，又叫<code>request(blob)</code>。</p>
  </li>
  <li>
    <p><code>deliver(seqno, prevhash, blob)</code>：共识服务调用它给伙伴发送带非负序列号<code>seqno</code>和最近一次发送发送消息的hash<code>prevhash</code>的消息<code>blob</code>。换句话说，它是共识服务的输出事件。<code>deliver()</code>在发布/订阅系统中叫<code>notify()</code>，BFT系统中叫<code>commit()</code>。</p>
  </li>
</ul>

<p>注意共识服务客户端（比如伙伴）只通过<code>broadcast()</code>和<code>deliver()</code>事件和服务进行交互。</p>

<p><strong>共识内容（Consensus properties）</strong>。共识服务（或者原子广播通道）有如下的保证，回答了这些问题：<code>广播消息发生了什么</code>，<code>交付消息间有什么关系</code>?</p>

<ol>
  <li><strong>安全性 - 一致性保证（Safety (consistency guarantees)）</strong>：只要伙伴连接到通道有足够的时间（它们可以断开或者宕掉，重启或者重新连接就可以），它们就能看到<code>相同</code>顺序的交付消息<code>(seqno, prevhash, blob)</code>。这意味着，给所有伙伴的输出（<code>deliver()</code>事件）都是<code>相同顺序</code>的，相同的序号都是<code>相同的内容</code>（<code>blob</code>和<code>prevhash</code>）。需要注意的是，这只是一个<code>逻辑顺序</code>，并且，给一个伙伴的<code>deliver(seqno, prevhash, blob)</code>并不需要和给另外一个伙伴输出的<code>deliver(seqno, prevhash, blob)</code>有时间上的关联。换句话说，给定一个特定的<code>seqno</code>，<code>没有</code>两个正常的伙伴会发送<code>不同</code>的<code>prevhash</code>和<code>blob</code>。而且是，除非有共识客户端（伙伴）真正的调用了<code>broadcast(blob) </code>，是不会发送<code>blob</code>消息的，最好呢，只发送<code>一次</code>每个广播的<code>blob</code>。</li>
</ol>

<p>还有，<code>deliver()</code>事件包含了上一个<code>deliver()</code>事件的加密哈希<code>prevhash</code>。当共识服务执行一个原子广播保证时，<code>prevhash</code>是序号为<code>seqno-1</code>的<code>deliver()</code>事件的加密哈希。这就在不同的<code>deliver()</code>的事件之间建立了一个哈希链，能够用来帮助验证共识输出的完整性，后面的第4和5部分会讨论这个。特殊情况是，第一个<code>deliver()</code>事件的<code>prevhash</code>有一个默认值。</p>

<ol>
  <li><strong>活跃度 - 交付保证（Liveness (delivery guarantee)）</strong>：共识服务的活跃度保证是共识服务的实现指定的。精确的保证要依赖网络和节点容错模型。</li>
</ol>

<p>原则上，如果提交没有失败，共识服务应该保证每个连接到共识服务的伙伴最终都能交付每个提交的交易。</p>

<p>总结一下，共识服务保证了下面的内容：</p>

<ul>
  <li>
    <p><em>协议（Agreement）</em>。正常伙伴的任意两个事件，<code>deliver(seqno, prevhash0, blob0)</code>和<code>deliver(seqno, prevhash1, blob1)</code>，如果有相同的<code>seqno</code>，则有<code>prevhash0==prevhash1</code>，<code>blob0==blob1</code>成立；</p>
  </li>
  <li>
    <p><em>哈希链完整性（Hashchain integrity）</em>。正常伙伴的任意两个事件，<code>deliver(seqno-1, prevhash0, blob0)</code>和<code>deliver(seqno, prevhash, blob)</code>，有<code>prevhash = HASH(seqno-1||prevhash0||blob0)</code>；</p>
  </li>
  <li>
    <p><em>不遗漏（No skipping）</em>。如果一个共识服务给一个正常节点<code>p</code>输出<code>deliver(seqno, prevhash, blob)</code>，如果<code>seqno&gt;0</code>，则<code>p</code>一定已经交付了<code>deliver(seqno-1, prevhash0, blob0)</code>事件；</p>
  </li>
  <li>
    <p><em>不创建（No creation）</em>。一个正常节点的任意<code>deliver(seqno, prevhash, blob)</code>事件，前面一定有一个伙伴发送了<code>broadcast(blob)</code>事件；</p>
  </li>
  <li>
    <p><em>不重复（No duplication，可选的）</em>。对任意的两个事件<code>broadcast(blob)</code>和<code>broadcast(blob')</code>，当正常伙伴交付了两个事件，<code>deliver(seqno0, prevhash0, blob)</code>和<code>deliver(seqno1, prevhash1, blob')</code>，如果<code>blob</code>==<code>blob'</code>，则有<code>seqno0==seqno1</code>和<code>prevhash0==prevhash1</code>成立；</p>
  </li>
  <li>
    <p><em>活跃度（Liveness）</em>。如果一个正常伙伴产生了<code>broadcast(blob)</code>事件，则每个正常伙伴“最终”都会发出一个<code>deliver(*, *, blob)</code>事件，其中<code>*</code>代表任意值。</p>
  </li>
</ul>

<h2 id="section-3">2. 交易背书的基本流程</h2>

<p>下面我们概要性的介绍一个交易的高层请求流程。</p>

<p><strong>备注</strong>：<em>注意后面的协议并不假定所有的交易都是确定性的，允许不确定性的交易</em>。</p>

<h3 id="section-4">2.1. 客户端创建一个交易并发送给自己选择的一个提交伙伴</h3>

<p>要调用一个交易，客户端发送如下的消息给提交伙伴<code>spID</code>。</p>

<p><code>&lt;SUBMIT,tx,retryFlag&gt;</code>，其中：</p>

<ul>
  <li><code>tx=&lt;clientID,chaincodeID,txPayload,clientSig&gt;</code>，其中：
    <ul>
      <li><code>clientID</code>是提交客户端的ID，</li>
      <li><code>chaincodeID</code>指的是交易所属的链码，</li>
      <li><code>txPayload</code>是提交的交易本身的有效载荷，</li>
      <li><code>clientSig</code>是客户端<code>tx</code>消息其他项的签名。</li>
    </ul>
  </li>
  <li><code>retryFlag</code>是一个布尔值，告诉提交伙伴万一交易失败了要不要重传，</li>
</ul>

<p>调用交易和部署交易的<code>txPayload</code>是不一样的（比如，调用交易会引用一个部署相关的系统链码）。如果是<strong>调用交易</strong>，<code>txPayload</code>只有一个项：</p>

<ul>
  <li><code>invocation = &lt;operation, metadata&gt;</code>，其中：
    <ul>
      <li><code>operation</code>代表链码的操作（函数）和参数，</li>
      <li><code>metadata</code>代表调用相关的属性。</li>
    </ul>
  </li>
</ul>

<p>如果是<strong>部署交易</strong>，会有两个项：</p>

<ul>
  <li><code>chainCode = &lt;source, metadata&gt;</code>，其中：
    <ul>
      <li><code>source</code>代表链码的源码路径，</li>
      <li><code>metadata</code>代表链码和应用相关的属性。</li>
    </ul>
  </li>
  <li><code>policies</code>包含了所有伙伴都能访问的链码策略，比如背书策略。</li>
</ul>

<p>TODO：确定是否要在客户端显示的包含本地/逻辑时间（时间戳）。</p>

<h3 id="section-5">2.2. 提交伙伴准备一个交易并发送给背书者获取背书</h3>

<p>提交伙伴收到客户端发来的<code>&lt;SUBMIT,tx,retryFlag&gt;</code>消息后，首先要验证客户端的签名<code>clientSig</code>，然后就准备交易。提交伙伴会临时的<em>执行</em>交易（<code>txPayload</code>），过程是通过执行交易关联（<code>chaincodeID</code>）的链码和拷贝提交伙伴本地保存的状态。</p>

<p>执行的结果，提交伙伴计算<em>状态更新</em>（<code>stateUpdate</code>）和<em>版本依赖</em>（<code>verDep</code>），这在DB语言中又叫<em>MVCC+postimage</em>。</p>

<p>还记得状态是键/值对（k/v）组成的吧。所有的k/v记录都是版本化的，就是说，每个记录都包含排过序的版本信息，每个键更新的时候都会递增版本信息。伙伴解析链码访问的交易记录键值对，可以读可以写，它还没有更新这个状态。更具体的说：</p>

<ul>
  <li><code>verDep</code>是一个元组<code>verDep=(readset,writeset)</code>。给定提交伙伴执行交易前的一个状态<code>s</code>：
    <ul>
      <li>对交易读取的每个键<code>k</code>，把<code>(k,s(k).version)</code>加入到<code>readset</code>中。</li>
      <li>对交易修改的每个键<code>k</code>，把<code>(k,s(k).version)</code>加入到<code>writeset</code>中。</li>
    </ul>
  </li>
  <li>另外，对交易修改的每个键<code>k</code>的新值<code>v'</code>，把<code>(k,v')</code>加入到<code>stateUpdate</code>中。<code>v'</code>也可以是新值相对旧值<code>s(k).value</code>的增量。</li>
</ul>

<p>实际的实现可以把<code>verDep.writeset</code>和<code>stateUpdate</code>放到同一个数据结构中。</p>

<p>然后，<code>tran-proposal := (spID,chaincodeID,txContentBlob,stateUpdate,verDep)</code>，其中：<code>txContentBlob</code>是链码/交易相关的信息，目的是能标识<code>tx</code>（比如，<code>txContentBlob=tx.txPayload</code>）。更详细的信息第6部分会介绍。</p>

<p>所有节点都会用<code>tran-proposal</code>的加密哈希来作唯一交易标识符<code>tid</code>（比如：<code>tid=HASH(tran-proposal)</code>）。</p>

<p>然后提交伙伴就把交易（<code>tran-proposal</code>）发送给链码的背书者。背书伙伴的选择是根据解析策略来的，还要看伙伴的可用性和提交伙伴的连通性。比如，可以把交易发送给指定<code>chaincodeID</code><em>所有</em>的背书者。这有可能，有的背书者是离线的，还有一些会拒绝对交易进行背书。提交伙伴尽量用可用的背书者满足策略要求。</p>

<p>提交伙伴<code>spID</code>给背书伙伴<code>epID</code>发送的交易消息是：</p>

<p><code>&lt;PROPOSE,tx,tran-proposal&gt;</code>。</p>

<p><strong>可能的优化</strong>：实现上可以优化下<code>tx.chaincodeID</code>和<code>tran-proposal.chaincodeID</code>里重复的<code>chaincodeID</code>，<code>tx.txPayload</code>和<code>tran-proposal.txContentBlob</code>里重复的<code>txPayload</code>。</p>

<p>最后，提交伙伴在内存中保存<code>tran-proposal</code>和<code>tid</code>，等待背书伙伴的回复。</p>

<p><strong>其他设计</strong>：<em>这里提交伙伴和背书伙伴是直接通信的。这可以是共识服务的一个功能，这种情况下，需要确定faric要不要原子广播交付保证还是直接用简单的p2p通信。这样共识服务也要负责根据策略收集背书再发送给提交伙伴</em>。</p>

<p>TODO：需要确定提交伙伴和背书伙伴之间的通信：用p2p还是通过共识服务。</p>

<h3 id="section-6">2.3. 背书服务和给交易背书</h3>

<p>链码<code>tran-proposal.chaincodeID</code>对应的背书伙伴收到通过<code>PROPOSE</code>消息发送来的交易后，执行如下步骤：</p>

<ul>
  <li>
    <p>背书者验证签名<code>tx.clientSig</code>，检查<code>tx.chaincodeID==tran-proposal.chaincodeID</code>。</p>
  </li>
  <li>
    <p>背书者模拟交易（用<code>tx.txPayload</code>），验证状态更新和依赖信息都是正确的。如果所有的都是有效的，它就对<code>(TRANSACTION-VALID, tid)</code>进行数字签名，生成<code>epSig</code>。然后背书伙伴发送<code>&lt;TRANSACTION-VALID, tid,epSig&gt;</code>消息给提交伙伴（<code>tran-proposal.spID</code>）。</p>
  </li>
  <li>
    <p>如果背书者模拟交易是失败了，有几种情况：</p>

    <p>a. 如果背书者获取到的状态更新和<code>tran-proposal.stateUpdates</code>里的不一样，它就对<code>(TRANSACTION-INVALID, tid, INCORRECT_STATE)</code>进行签名并发送给提交伙伴。</p>

    <p>b. 如果背书者发现了比<code>tran-proposal.verDeps</code>更新的数据版本，它就对<code>(TRANSACTION-INVALID, tid, STALE_VERSION)</code>进行签名并发送给提交伙伴。</p>

    <p>c. 如果背书者因为其他的一些理由（内部的背书策略、交易错误等）不想对交易进行背书，它就对<code>(TRANSACTION-INVALID, tid, REJECTED)</code>进行签名并发送给提交伙伴。</p>
  </li>
</ul>

<p>注意背书者在这一步还没有改变状态，状态的更新也不会写日志。</p>

<p><strong>其他设计</strong>：<em>对无效交易，背书伙伴可以不通知提交伙伴，不用显示的发送<code>TRANSACTION-INVALID</code>通知，</em>。</p>

<p><strong>其他设计</strong>：<em>背书伙伴把<code>TRANSACTION-VALID/TRANSACTION-INVALID</code>消息及其签名提交给共识服务</em>。</p>

<p>TODO：确定采用上面的哪种设计。</p>

<h3 id="section-7">2.4. 提交伙伴收集交易的背书并通过共识服务进行广播</h3>

<p>提交伙伴等待接收足够的信息和对<code>(TRANSACTION-VALID, tid)</code>进行的签名，表明交易提议（transaction proposal）是有背书（可能包含它自己的签名）的。这个过程依赖背书策略（再看看第3部分）。如果满足背书策略，交易就有<code>背书</code>了，注意这会儿还没有成功交付。从背书伙伴收集到的有背书交易的签名就叫<em>背书（endorsement）</em>，提交伙伴把它们存储到<code>endorsement</code>里。</p>

<p>如果提交伙伴没有收集到交易提议的背书，它就丢弃掉这个交易并通知提交客户端。如果提交客户端设置（看步骤1和<code>SUBMIT</code>消息）了<code>retryFlag</code>，提交伙伴可能（根据提交伙伴的策略）会对交易进行重试（步骤2）。</p>

<p>对一个有效背书的交易，我们开始使用consensus-fabric。提交伙伴使用<code>broadcast(blob)</code>调用共识服务，其中<code>blob=(tran-proposal, endorsement)</code>。</p>

<h3 id="section-8">2.5. 共识服务给伙伴发布交易</h3>

<p>当出现一个<code>deliver(seqno, prevhash, blob)</code>事件，一个伙伴更新所有序号小于<code>seqno</code>消息的状态，过程是这样的：</p>

<ul>
  <li>
    <p>伙伴根据链码（<code>blob.tran-proposal.chaincodeID</code>）的策略检查<code>blob.endorsement</code>是否有效（这个步骤可以不用等到序号小于<code>seqno</code>的状态更新这个时候）。</p>
  </li>
  <li>
    <p>伙伴同时验证依赖<code>blob.tran-proposal.verDep</code>是有效的。</p>
  </li>
</ul>

<p>根据状态更新选择的一致性内容（consistency property）或者“隔离保证（isolation guarantee）”不同，依赖验证有多种实现方式。比如，<strong>可串行性（serializability）</strong>可以要求每个<code>readset</code>和<code>writeset</code>里键对应的版本号必须和状态里面键的版本号相同，丢掉不能满足这个要求的交易。另外一个例子，<strong>快照隔离（snapshot isolation ）</strong>要求<code>writeset</code>里所有的键，状态里的键和依赖数据里的版本号都一样。数据库要求更多的隔离保证。</p>

<p>TODO：确定坚持可串行性还是允许链码指定隔离级别。</p>

<ul>
  <li>
    <p>如果所有的检查都通过了，这个交易就被认为是<em>有效的（valid）</em>或者<em>已交付的（committed）</em>。这就是说，一个伙伴添加一个交易到总账上，然后会在区块链状态上执行<code>blob.tran-proposal.stateUpdates</code>。只有已交付的交易才会修改状态。</p>
  </li>
  <li>
    <p>如果有检查失败了，交易就是无效的，伙伴会丢弃这个交易。重要的是要注意无效的交易是没有交付的，不会修改状态，也不会被记录。</p>
  </li>
</ul>

<p>另外，提交伙伴会通知客户端丢弃的交易。如果提交客户端设置（看步骤1和<code>SUBMIT</code>消息）了<code>retryFlag</code>，提交伙伴可能（根据提交伙伴的策略）会对交易进行重试（步骤2）。</p>

<p><img src="https://gerrit.hyperledger.org/r/gitweb?p=fabric.git;a=blob_plain;f=proposals/r1/flow-2.png" alt="交易流程图解" /></p>

<p>图1. 交易流程图解（通用情况路径）</p>

<hr />

<h2 id="section-9">3. 背书策略</h2>

<h3 id="section-10">3.1. 背书策略规范</h3>

<p><strong>背书策略</strong>是对交易进行背书的<em>条件</em>。背书策略是链码安装的时候<code>deploy</code>交易指定的。只有根据策略进行背书的交易才是有效的。链码的调用交易会先获取链码策略的背书，否则是交付不了的。这是通过提交伙伴和背书伙伴之间的交互完成的，在第2部分已经介绍过了。</p>

<p>形式上，背书策略是关于特定变量的断言。实际上，它可以是：</p>

<ol>
  <li>链码相关的键或者标识符（链码的元数据里面能找到），比如，背书者集合；</li>
  <li>更多的链码元数据；</li>
  <li>交易本身的元素；</li>
  <li>可能还有其他的。</li>
</ol>

<p>背书策略断言的评估必须是确定性的。背书策略不能是复杂的，也不能是“小链码（mini chaincode）”。背书策略规范语言是有限制的，并且能够增加确定性。</p>

<p>断言列表是由简单到丰富，复杂性是由易到难的。就是说，支持只有节点的键和标识符的策略是相对比较简单的。</p>

<p>TODO：确定背书策略的参数。</p>

<p>断言可能包含结果是TRUE或者FALSE的逻辑表达式。一般情况下，条件会用链码的背书伙伴对交易调用签发的数字签名。</p>

<p>假链码指定了一个背书者集合<code>E = {Alice, Bob, Charlie, Dave, Eve, Frank, George}</code>，一些策略的示例：</p>

<ul>
  <li>
    <p>E集合所有元素的有效签名。</p>
  </li>
  <li>
    <p>E集合任意一个元素的有效签名。</p>
  </li>
  <li>
    <p>满足<code>(Alice OR Bob) AND (any two of: Charlie, Dave, Eve, Frank, George)</code>这个条件的背书伙伴的有效签名。</p>
  </li>
  <li>
    <p>7个背书者中任意5个的有效签名。（更通用的情况是，有<code>n &gt; 3f</code>个背书者的链码，需要<code>n</code>个背书者中有<code>2f+1</code>个有有效签名，或者任意一个<em>超过</em><code>(n+f)/2</code>个背书者的组有有效签名。）。</p>
  </li>
  <li>
    <p>假设背书者都有一个“投注”或者“权重”，比如<code>{Alice=49, Bob=15, Charlie=15, Dave=10, Eve=7, Frank=3, George=1}</code>，总投注是100：策略要求多数投注集合的有效签名（比如，一个总投注严格大于50的组），只要和George的<code>X</code>不一样的<code>{Alice, X}</code>，或者{everyone together except Alice}等等。</p>
  </li>
  <li>
    <p>上面的例子里投注可以是静态的（链码的元数据里写死的）或者动态的（比如，依赖链码的状态并且可以在执行过程中修改）。</p>
  </li>
</ul>

<p>这些策略能起到多少作用还依赖应用程序，对背书者错误或者捣乱需要的恢复力，还有其他不同的属性。</p>

<h3 id="section-11">3.2. 实现</h3>

<p>一般情况，背书策略都。</p>

  </div>
</div>


      </div>
      <hr>
      <footer>
        <p>&copy; 2016
          <a href="" target="_blank" title="区块链实用手册">区块链实用手册</a>
            原创文章的版权均属于 <a href="https://wutongtree.com" target="_blank" title="梧桐树">梧桐树</a> 所有，如需合作请联系<a href="mailto:hyper@crypto2x.com" target="_blank">我们</a> <br>
	    With help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
            and <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>
          </p>
        </footer>
  
    </div>

    



  </body>
</html>

